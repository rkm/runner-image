#!/usr/bin/env python3
from __future__ import annotations

import argparse
import datetime
import functools
import json
import os
import re
import shutil
import subprocess
import tempfile
import urllib.parse
import urllib.request
from typing import Any
from typing import NamedTuple

from bs4 import BeautifulSoup

# Temp
ORG = 'rkm'

DEFAULT_BRANCH = 'master'
REPO_ROOT = os.getcwd()


class LangUpdateInfo(NamedTuple):
    old_ver: str
    new_ver: str
    dockerfile_lines: list[str]


def _check_dotnet(dockerfile_lines: list[str]) -> LangUpdateInfo | None:
    print('\n## dotnet')

    dotnet_url_re = re.compile(r'^(ARG DOTNET_URL=)(.*)$')
    dotnet_sha_re = re.compile(r'^(ARG DOTNET_SHA512=)(.*)$')

    # 1. Read current version

    current_ver = None
    for line in dockerfile_lines:
        line_match = dotnet_url_re.match(line)
        if line_match:
            current_url = line_match.group(2)
            version_match = re.match(
                r'.*dotnet-sdk-(.*)-linux-x64.tar.gz',
                current_url,
            )
            assert version_match
            current_ver = version_match.group(1)
            break

    if not current_ver:
        print('Error: Could not detect version')
        return None
    else:
        print(f"Current version is '{current_ver}'")

    # 2. Check for a newer version

    with urllib.request.urlopen(
        'https://api.github.com/repos/dotnet/installer/releases'
        '?per_page=5',
    ) as f:
        releases = json.loads(f.read())

    releases_sorted = sorted(
        releases,
        key=lambda x: datetime.datetime.fromisoformat(
            x['created_at'][:-1],
        ),
        reverse=True,
    )

    candidate_ver = None

    # Check for newer major SDK versions, which may be published before
    # releases of the current SDK major version
    for release in releases_sorted:

        # tag format is "v" + a SemVer string, possibly including a build tag
        release_ver_long = release['tag_name'][1:]
        release_major = int(release_ver_long[0])

        if release_major > int(current_ver[0]):
            candidate_ver = release_ver_long
            break

        if not candidate_ver:
            candidate_ver = release_ver_long

    # 3. Exit if we have the latest

    if not candidate_ver:
        print('Have latest version')
        return None

    print(f"New version detected: '{candidate_ver}'")

    # 4. Get new URL and checksum

    def strip_build_version(version: str) -> str:
        """
        Extract version for URL from tag, e.g.
        v6.0.100-rc.1.21458.32      -> 6.0.100-rc.1
        v6.0.100-preview.7.21379.14 -> 6.0.100-preview.7
        v5.0.401                    -> 5.0.401
        """
        sep_indexes = [i for i, c in enumerate(version) if c == '.']
        return version if len(sep_indexes) == 2 else version[:sep_indexes[3]]

    new_version = strip_build_version(candidate_ver)

    with urllib.request.urlopen(
        'https://dotnet.microsoft.com/download/dotnet/thank-you/'
        f'sdk-{new_version}-linux-x64-binaries',
    ) as f:
        soup = BeautifulSoup(f.read(), 'html.parser')

    download_url = soup.find(id='directLink').text
    sha512 = soup.find(id='checksum').get('value')

    # 5. Replace lines in Dockerfile

    replacements = {
        dotnet_url_re: download_url,
        dotnet_sha_re: sha512,
    }

    new_dockerfile_lines = []
    for line in dockerfile_lines:
        for rep in replacements:
            subst = re.sub(rep, fr'\g<1>{replacements[rep]}', line)
            if subst != line:
                line = subst
                del replacements[rep]
                break
        new_dockerfile_lines.append(line)

    if replacements:
        print(f'Error: unused replacements {replacements}')
        return None

    return LangUpdateInfo(
        strip_build_version(current_ver),
        new_version,
        new_dockerfile_lines,
    )


def _run(*cmd: str, capture: bool = False, **kwargs: Any) -> str | None:
    subprocess.check_call(('echo', '$', *cmd))
    if capture:
        output = subprocess.check_output(cmd, **kwargs).decode().strip()
        print(output)
        return output
    else:
        subprocess.check_call(cmd, **kwargs)
        return None


def _create_lang_updates(
    tempdir: str,
    updates: dict[str, LangUpdateInfo],
    gh_token: str,
) -> None:

    git_files = _run('git', 'ls-files', capture=True)
    assert git_files
    for f in git_files.split():
        d = os.path.join(tempdir, os.path.dirname(f))
        os.makedirs(d, exist_ok=True)
        shutil.copy2(f, d)
    shutil.copytree(
        os.path.join(REPO_ROOT, '.git'),
        os.path.join(tempdir, '.git'),
    )

    run = functools.partial(_run, cwd=tempdir)

    for lang in updates:

        lang_branch = f'autoupdate-lang-{lang}'
        update_title = (
            f'autoupdate {lang} '
            f'from {updates[lang].old_ver} '
            f'to {updates[lang].new_ver}'
        )

        run('git', 'reset', '--hard')
        run('git', 'checkout', DEFAULT_BRANCH)

        try:
            run('git', 'branch', '-D', lang_branch)
        except subprocess.CalledProcessError:
            pass
        run('git', 'checkout', '-b', lang_branch)

        with open(os.path.join(tempdir, 'Dockerfile'), 'w') as fp:
            fp.writelines(updates[lang].dockerfile_lines)

        run('git', 'diff', capture=True)
        run('git', 'add', 'Dockerfile')
        run('git', 'commit', '-m', update_title)
        run('git', 'push', ORG, 'HEAD', '--force')

        data = json.dumps({
            'head': lang_branch,
            'base': DEFAULT_BRANCH,
            'title': update_title,
            'body': '',
            'maintainer_can_modify': True,
        }).encode()
        req = urllib.request.Request(
            f'https://api.github.com/repos/{ORG}/runner-image/pulls',
            headers={
                'accept': 'application/vnd.github.v3+json',
                'Authorization': f'token {gh_token}',
            },
            data=data,
        )
        with urllib.request.urlopen(req) as resp:
            print(f'{lang} PR: {resp.msg}')


def main() -> int:

    parser = argparse.ArgumentParser()
    parser.add_argument('-l', '--languages', help='Selected languages only')
    parser.add_argument(
        '-d', '--dry-run',
        default=False,
        action='store_true',
        help="Check only; don't create any PRs",
    )
    args = parser.parse_args()

    selected_langs = (
        set(args.languages.split(','))
        if args.languages
        else set()
    )
    all_langs = set()

    dockerfile_lang_re = re.compile(r".*'lang: (.*)'.*")

    with open('Dockerfile') as f:
        dockerfile_lines = f.readlines()

    for line in dockerfile_lines:
        match = dockerfile_lang_re.match(line)
        if match:
            all_langs.add(match.group(1))

    for lang in selected_langs:
        if lang not in all_langs:
            print(f"Error: Unknown language '{lang}'")
            return 1

    if not selected_langs:
        selected_langs = all_langs

    lang_checks_map = {
        'dotnet': _check_dotnet,
    }

    updates = {}
    for lang in selected_langs:
        if lang not in lang_checks_map:
            print(f"Error: No handler for '{lang}'")
            return 1
        else:
            update_info = lang_checks_map[lang](dockerfile_lines)
            if update_info:
                updates[lang] = update_info
                print(
                    f'{lang}: update from {update_info.old_ver} '
                    f'to {update_info.new_ver}',
                )
    print()

    if updates and not args.dry_run:

        gh_token = os.environ.get('GITHUB_TOKEN', None)
        if not gh_token:
            print('Error: $GITHUB_TOKEN requried')
            return 1

        # work in a tempdir for git operations, mostly so developing this
        # script isn't a pain
        with tempfile.TemporaryDirectory() as tempdir:
            _create_lang_updates(tempdir, updates, gh_token)
    else:
        print('no updates, or dry-run selected')

    return 0


if __name__ == '__main__':
    raise SystemExit(main())
