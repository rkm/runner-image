#!/usr/bin/env python3
from __future__ import annotations

import argparse
import datetime
import json
import re
import subprocess
import urllib.request
from typing import NamedTuple

from bs4 import BeautifulSoup


class LangUpdateInfo(NamedTuple):
    old_ver: str
    new_ver: str
    dockerfile_lines: list[str]


def _check_dotnet(dockerfile_lines: list[str]) -> LangUpdateInfo | None:
    print('\n## dotnet')

    dotnet_url_re = re.compile(r'^(ARG DOTNET_URL=)(.*)$')
    dotnet_sha_re = re.compile(r'^(ARG DOTNET_SHA512=)(.*)$')

    # 1. Read current version

    current_ver = None
    for line in dockerfile_lines:
        line_match = dotnet_url_re.match(line)
        if line_match:
            current_url = line_match.group(2)
            version_match = re.match(
                r'.*dotnet-sdk-(.*)-linux-x64.tar.gz',
                current_url,
            )
            assert version_match
            current_ver = version_match.group(1)
            break

    if not current_ver:
        print('Error: Could not detect version')
        return None
    else:
        print(f"Current version is '{current_ver}'")

    # 2. Check for a newer version

    with urllib.request.urlopen(
        'https://api.github.com/repos/dotnet/installer/releases'
        '?per_page=5',
    ) as f:
        releases = json.loads(f.read())

    releases_sorted = sorted(
        releases,
        key=lambda x: datetime.datetime.fromisoformat(
            x['created_at'][:-1],
        ),
        reverse=True,
    )

    candidate_ver = None

    # Check for newer major SDK versions, which may be published before
    # releases of the current SDK major version
    for release in releases_sorted:

        # tag format is "v" + a SemVer string, possibly including a build tag
        release_ver_long = release['tag_name'][1:]
        release_major = int(release_ver_long[0])

        if release_major > int(current_ver[0]):
            candidate_ver = release_ver_long
            break

        if not candidate_ver:
            candidate_ver = release_ver_long

    # 3. Exit if we have the latest

    if not candidate_ver:
        print('Have latest version')
        return None

    print(f"New version detected: '{candidate_ver}'")

    # 4. Get new URL and checksum

    def strip_build_version(version: str) -> str:
        """
        Extract version for URL from tag, e.g.
        v6.0.100-rc.1.21458.32      -> 6.0.100-rc.1
        v6.0.100-preview.7.21379.14 -> 6.0.100-preview.7
        v5.0.401                    -> 5.0.401
        """
        sep_indexes = [i for i, c in enumerate(version) if c == '.']
        return version if len(sep_indexes) == 2 else version[:sep_indexes[3]]

    new_version = strip_build_version(candidate_ver)

    with urllib.request.urlopen(
        'https://dotnet.microsoft.com/download/dotnet/thank-you/'
        f'sdk-{new_version}-linux-x64-binaries',
    ) as f:
        soup = BeautifulSoup(f.read(), 'html.parser')

    download_url = soup.find(id='directLink').text
    sha512 = soup.find(id='checksum').get('value')

    # 5. Replace lines in Dockerfile

    replacements = {
        dotnet_url_re: download_url,
        dotnet_sha_re: sha512,
    }

    new_dockerfile_lines = []
    for line in dockerfile_lines:
        for rep in replacements:
            subst = re.sub(rep, fr'\g<1>{replacements[rep]}', line)
            if subst != line:
                line = subst
                del replacements[rep]
                break
        new_dockerfile_lines.append(line)

    if replacements:
        print(f'Error: unused replacements {replacements}')
        return None

    return LangUpdateInfo(
        strip_build_version(current_ver),
        new_version,
        new_dockerfile_lines,
    )


def _run(*cmd: str, capture: bool = False) -> str | None:
    subprocess.check_call(('echo', '$', *cmd))
    if capture:
        output = subprocess.check_output(cmd).decode().strip()
        print(output)
        return output
    else:
        subprocess.check_call(cmd)
        return None


def _create_lang_update(lang: str, info: LangUpdateInfo) -> None:

    print(f'\n## creating update for {lang}')
    orig_branch = _run(
        'git', 'rev-parse', '--abbrev-ref', 'HEAD',
        capture=True,
    )
    assert orig_branch

    lang_branch = f'autoupdate-lang-{lang}'
    try:
        _run('git', 'branch', '-D', lang_branch)
        _run('git', 'checkout', '-b', lang_branch, 'master')
        _run('git', 'checkout', 'master', '--', 'Dockerfile')
        _run('cp', f'Dockerfile.{lang}', 'Dockerfile')
        _run('git', 'diff', capture=True)
        _run('git', 'add', 'Dockerfile')
        _run('git', 'commit', '-m"autoupdate dotnet to {info.new_ver}"')
    finally:
        _run('git', 'checkout', orig_branch)
        _run('git', 'stash', 'pop')

    # TODO(rkm 2021-09-21) Post PR using GH API


def main() -> int:

    parser = argparse.ArgumentParser()
    parser.add_argument('-l', '--languages', help='Selected languages only')
    parser.add_argument(
        '-d', '--dry-run',
        default=False,
        action='store_true',
        help="Check only; don't create any PRs",
    )
    args = parser.parse_args()

    selected_langs = (
        set(args.languages.split(','))
        if args.languages
        else set()
    )
    all_langs = set()

    dockerfile_lang_re = re.compile(r".*'lang: (.*)'.*")

    with open('Dockerfile') as f:
        dockerfile_lines = f.readlines()

    for line in dockerfile_lines:
        match = dockerfile_lang_re.match(line)
        if match:
            all_langs.add(match.group(1))

    for lang in selected_langs:
        if lang not in all_langs:
            print(f"Error: Unknown language '{lang}'")
            return 1

    if not selected_langs:
        selected_langs = all_langs

    lang_checks_map = {
        'dotnet': _check_dotnet,
    }

    for lang in selected_langs:
        if lang not in lang_checks_map:
            print(f"Error: No handler for '{lang}'")
            return 1
        else:
            update_info = lang_checks_map[lang](dockerfile_lines)
            # update_info = LangUpdateInfo(
            #     'dotnet',
            #     'v1',
            #     'v2',
            #     'PR text here!',
            # )
            if update_info and not args.dry_run:
                _create_lang_update(lang, update_info)

    return 0


if __name__ == '__main__':
    raise SystemExit(main())
